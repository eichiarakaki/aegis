package core

import (
	"fmt"
	"strings"
)

type Requires struct {
	Klines               *bool `json:"klines,omitempty"`
	LiquidationSnapshots *bool `json:"liquidation_snapshots,omitempty"`
	Metrics              *bool `json:"metrics,omitempty"`
	AggTrades            *bool `json:"agg_trades,omitempty"`
	BookDepth            *bool `json:"book_depth,omitempty"`
	Trades               *bool `json:"trades,omitempty"`
}

type ComponentStateType int

const (
	ComponentPending ComponentStateType = iota
	ComponentStarting
	ComponentRunning
	ComponentStopping
	ComponentStopped
	ComponentFinished
	ComponentError
)

func ComponentStateToString(state ComponentStateType) string {
	switch state {
	case ComponentPending:
		return "Pending"
	case ComponentStarting:
		return "Starting"
	case ComponentRunning:
		return "Running"
	case ComponentStopping:
		return "Stopping"
	case ComponentStopped:
		return "Stopped"
	case ComponentFinished:
		return "Finished"
	case ComponentError:
		return "Error"
	default:
		return "Unknown"
	}
}

type Component struct {
	ID                  *string     `json:"id,omitempty"` // NORMALLY GENERATED BY AEGIS, NOT PROVIDED BY COMPONENT
	Name                string      `json:"component_name"`
	Requires            *[]Requires `json:"requires,omitempty"` // OPTIONAL: If not provided, Aegis assumes no dependencies
	SupportedSymbols    []string    `json:"supported_symbols"`
	SupportedTimeframes []string    `json:"supported_timeframes"`
	State               ComponentStateType
}

const ValidIntervals = "1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,1M"

func (c *Component) ValidateInterval() error {
	for _, interval := range c.SupportedTimeframes {
		if !strings.Contains(ValidIntervals, interval) {
			return fmt.Errorf("invalid interval: %s", interval)
		}
	}
	return nil
}
